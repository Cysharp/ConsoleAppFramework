namespace ConsoleAppFramework;

public static class ConsoleAppBaseCode
{
    public const string GeneratedCodeHeader = """
// <auto-generated/>
#nullable enable
#pragma warning disable

namespace ConsoleAppFramework;

using System;
using System.Text;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;

""";

    public const string InitializationCode = """
// <auto-generated/>
#nullable enable
#pragma warning disable

namespace ConsoleAppFramework;

using System;
using System.Text;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;

#if !USE_EXTERNAL_CONSOLEAPP_ABSTRACTIONS

internal interface IArgumentParser<T>
{
    static abstract bool TryParse(ReadOnlySpan<char> s, out T result);
}

internal record ConsoleAppContext
{
    public string CommandName { get; init; }
    public string[] Arguments { get; init; }
    public object? State { get; init; }
    public object? GlobalOptions { get; init; }
    internal int CommandDepth { get; }
    internal int EscapeIndex  { get; }
    internal string[] InternalCommandArgs { get; }

    public ReadOnlySpan<string> CommandArguments
    {
        get => (EscapeIndex == -1)
            ? Arguments.AsSpan(CommandDepth)
            : Arguments.AsSpan(CommandDepth, EscapeIndex - CommandDepth);
    }

    public ReadOnlySpan<string> EscapedArguments
    {
        get => (EscapeIndex == -1)
            ? Array.Empty<string>()
            : Arguments.AsSpan(EscapeIndex + 1);
    }

    public ConsoleAppContext(string commandName, string[] arguments, string[] commandArgs, object? state, object? globalOptions, int commandDepth, int escapeIndex)
    {
        this.CommandName = commandName;
        this.Arguments = arguments;
        this.InternalCommandArgs = commandArgs;
        this.State = state;
        this.GlobalOptions = globalOptions;
        this.CommandDepth = commandDepth;
        this.EscapeIndex = escapeIndex;
    }

    public override string ToString()
    {
        return string.Join(" ", Arguments);
    }
}

internal abstract class ConsoleAppFilter(ConsoleAppFilter next)
{
    protected readonly ConsoleAppFilter Next = next;

    public abstract Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken);
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = false)]
internal sealed class ConsoleAppFilterAttribute<T> : Attribute
    where T : ConsoleAppFilter
{
}

internal sealed class ArgumentParseFailedException(string message) : Exception(message)
{
}

#endif

[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
internal sealed class FromServicesAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
internal sealed class ArgumentAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
internal sealed class CommandAttribute : Attribute
{
    public string Command { get; }

    public CommandAttribute(string command)
    {
        this.Command = command;
    }
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
internal sealed class HiddenAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal sealed class RegisterCommandsAttribute : Attribute
{
    public string CommandPath { get; }

    public RegisterCommandsAttribute()
    {
        this.CommandPath = "";
    }

    public RegisterCommandsAttribute(string commandPath)
    {
        this.CommandPath = commandPath;
    }
}

[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
internal sealed class HideDefaultValueAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false, Inherited = false)]
internal class ConsoleAppFrameworkGeneratorOptionsAttribute : Attribute
{
    public bool DisableNamingConversion { get; set; }
}

internal delegate object FuncGlobalOptionsBuilderObject(ref ConsoleApp.GlobalOptionsBuilder builder);

[UnconditionalSuppressMessage("Trimming", "IL2026")]
[UnconditionalSuppressMessage("AOT", "IL3050")]
internal static partial class ConsoleApp
{
    public static IServiceProvider? ServiceProvider { get; set; }
    public static TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(5);
    public static System.Text.Json.JsonSerializerOptions? JsonSerializerOptions { get; set; }
    public static string? Version { get; set; }

    static Action<string>? logAction;
    public static Action<string> Log
    {
        get => logAction ??= Console.WriteLine;
        set => logAction = value;
    }

    static Action<string>? logErrorAction;
    public static Action<string> LogError
    {
        get => logErrorAction ??= (static msg => Log(msg));
        set => logErrorAction = value;
    }

    /// <summary>
    /// <para>You can pass second argument that generates new Run overload.</para>
    /// ConsoleApp.Run(args, (int x, int y) => { });<br/>
    /// ConsoleApp.Run(args, Foo);<br/>
    /// ConsoleApp.Run(args, &amp;Foo);<br/>
    /// </summary>
    public static void Run(string[] args)
    {
    }

    /// <summary>
    /// <para>You can pass second argument that generates new RunAsync overload.</para>
    /// ConsoleApp.RunAsync(args, (int x, int y) => { });<br/>
    /// ConsoleApp.RunAsync(args, Foo);<br/>
    /// ConsoleApp.RunAsync(args, &amp;Foo);<br/>
    /// </summary>
    public static Task RunAsync(string[] args)
    {
        return Task.CompletedTask;
    }

    public static ConsoleAppBuilder Create() => new ConsoleAppBuilder();

    static void ThrowArgumentParseFailed(string argumentName, string value)
    {
        throw new ArgumentParseFailedException($"Argument '{argumentName}' failed to parse, provided value: {value}");
    }

    static void ThrowRequiredArgumentNotParsed(string name)
    {
        throw new ArgumentParseFailedException($"Required argument '{name}' was not specified.");
    }

    static void ThrowArgumentNameNotFound(string argumentName)
    {
        throw new ArgumentParseFailedException($"Argument '{argumentName}' is not recognized.");
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool TryIncrementIndex(ref int index, int length)
    {
        if ((index + 1) < length)
        {
            index += 1;
            return true;
        }
        return false;
    }

    static bool TryParseParamsArray<T>(ReadOnlySpan<string> args, ref T[] result, ref int i)
       where T : IParsable<T>
    {
        result = new T[args.Length - i];
        var resultIndex = 0;
        for (; i < args.Length; i++)
        {
            if (!T.TryParse(args[i], null, out result[resultIndex++]!)) return false;
        }
        return true;
    }

    static bool TrySplitParse<T>(ReadOnlySpan<char> s, out T[] result)
       where T : ISpanParsable<T>
    {
        if (s.StartsWith("["))
        {
            try
            {
                result = System.Text.Json.JsonSerializer.Deserialize<T[]>(s, JsonSerializerOptions)!;
                return true;
            }
            catch
            {
                result = default!;
                return false;
            }
        }

        var count = s.Count(',') + 1;
        result = new T[count];

        var source = s;
        var destination = result.AsSpan();
        Span<Range> ranges = stackalloc Range[Math.Min(count, 128)];

        while (true)
        {
            var splitCount = source.Split(ranges, ',');
            var parseTo = splitCount;
            if (splitCount == 128 && source[ranges[^1]].Contains(','))
            {
                parseTo = splitCount - 1;
            }

            for (int i = 0; i < parseTo; i++)
            {
                if (!T.TryParse(source[ranges[i]], null, out destination[i]!))
                {
                    return false;
                }
            }
            destination = destination.Slice(parseTo);

            if (destination.Length != 0)
            {
                source = source[ranges[^1]];
                continue;
            }
            else
            {
                break;
            }
        }

        return true;
    }

    static void ValidateParameter(object? value, ParameterInfo parameter, ValidationContext validationContext, ref StringBuilder? errorMessages)
    {
        validationContext.DisplayName = parameter.Name ?? "";
        validationContext.Items.Clear();

        foreach (var validator in parameter.GetCustomAttributes<ValidationAttribute>(false))
        {
            var result = validator.GetValidationResult(value, validationContext);
            if (result != null)
            {
                if (errorMessages == null)
                {
                    errorMessages = new StringBuilder();
                }
                errorMessages.AppendLine(result.ErrorMessage);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool TryShowHelpOrVersion(ReadOnlySpan<string> args, int requiredParameterCount, int helpId)
    {
        if (args.Length == 0)
        {
            if (requiredParameterCount == 0) return false;

            ShowHelp(helpId);
            return true;
        }

        if (args.Length == 1)
        {
            switch (args[0])
            {
                case "--version":
                    ShowVersion();
                    return true;
                case "-h":
                case "--help":
                    ShowHelp(helpId);
                    return true;
                default:
                    break;
            }
        }

        return false;
    }

    static void ShowVersion()
    {
        if (Version != null)
        {
            Log(Version);
            return;
        }

        var asm = Assembly.GetEntryAssembly();
        var version = "1.0.0";
        var infoVersion = asm!.GetCustomAttribute<AssemblyInformationalVersionAttribute>();
        if (infoVersion != null)
        {
            version = infoVersion.InformationalVersion;
            var i = version.IndexOf('+');
            if (i != -1)
            {
                version = version.Substring(0, i);
            }
        }
        else
        {
            var asmVersion = asm!.GetCustomAttribute<AssemblyVersionAttribute>();
            if (asmVersion != null)
            {
                version = asmVersion.Version;
            }
        }
        Log(version);
    }

    static partial void ShowHelp(int helpId);

    sealed class PosixSignalHandler : IDisposable
    {
        public CancellationToken Token => cancellationTokenSource.Token;
        public CancellationToken TimeoutToken => timeoutCancellationTokenSource.Token;

        CancellationTokenSource cancellationTokenSource;
        CancellationTokenSource timeoutCancellationTokenSource;
        TimeSpan timeout;

        PosixSignalRegistration? sigInt;
        PosixSignalRegistration? sigQuit;
        PosixSignalRegistration? sigTerm;

        PosixSignalHandler(TimeSpan timeout, CancellationToken cancellationToken)
        {
            this.cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            this.timeoutCancellationTokenSource = new CancellationTokenSource();
            this.timeout = timeout;
        }

        public static PosixSignalHandler Register(TimeSpan timeout, CancellationToken cancellationToken)
        {
            var handler = new PosixSignalHandler(timeout, cancellationToken);

            Action<PosixSignalContext> handleSignal = handler.HandlePosixSignal;

            handler.sigInt = PosixSignalRegistration.Create(PosixSignal.SIGINT, handleSignal);
            handler.sigQuit = PosixSignalRegistration.Create(PosixSignal.SIGQUIT, handleSignal);
            handler.sigTerm = PosixSignalRegistration.Create(PosixSignal.SIGTERM, handleSignal);

            return handler;
        }

        void HandlePosixSignal(PosixSignalContext context)
        {
            context.Cancel = true;
            cancellationTokenSource.Cancel();
            timeoutCancellationTokenSource.CancelAfter(timeout);
        }

        public void Dispose()
        {
            sigInt?.Dispose();
            sigQuit?.Dispose();
            sigTerm?.Dispose();
            cancellationTokenSource.Dispose();
            timeoutCancellationTokenSource.Dispose();
        }
    }

    struct SyncAsyncDisposeWrapper<T>(T value) : IDisposable
        where T : IAsyncDisposable
    {
        public readonly T Value => value;

        public void Dispose()
        {
            value.DisposeAsync().AsTask().GetAwaiter().GetResult();
        }
    }

    internal partial class ConsoleAppBuilder
    {
        FuncGlobalOptionsBuilderObject? configureGlobalOptions;

        public ConsoleAppBuilder()
        {
        }

        public void Add(string commandName, Delegate command)
        {
            AddCore(commandName, command);
        }

        [System.Diagnostics.Conditional("DEBUG")]
        public void Add<T>() { }

        [System.Diagnostics.Conditional("DEBUG")]
        public void Add<T>(string commandPath) { }

        [System.Diagnostics.Conditional("DEBUG")]
        public void UseFilter<T>() where T : ConsoleAppFilter { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        partial void AddCore(string commandName, Delegate command);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        partial void RunCore(string[] args, CancellationToken cancellationToken);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        partial void RunAsyncCore(string[] args, CancellationToken cancellationToken, ref Task result);

        partial void BuildAndSetServiceProvider(ConsoleAppContext context);

        partial void StartHostAsyncIfNeeded(CancellationToken cancellationToken, ref Task task);

        static partial void ShowHelp(int helpId);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool TryShowHelpOrVersion(ReadOnlySpan<string> args, int requiredParameterCount, int helpId)
        {
            if (args.Length == 0)
            {
                if (requiredParameterCount == 0) return false;

                ShowHelp(helpId);
                return true;
            }

            if (args.Length == 1)
            {
                switch (args[0])
                {
                    case "--version":
                        ShowVersion();
                        return true;
                    case "-h":
                    case "--help":
                        ShowHelp(helpId);
                        return true;
                    default:
                        break;
                }
            }

            return false;
        }

        public ConsoleAppBuilder ConfigureGlobalOptions(FuncGlobalOptionsBuilderObject configure)
        {
            this.configureGlobalOptions = configure;
            return this;
        }

        async Task RunWithFilterAsync(string commandName, string[] args, int commandDepth, int escapeIndex, ConsoleAppFilter invoker, CancellationToken cancellationToken)
        {
            using var posixSignalHandler = PosixSignalHandler.Register(Timeout, cancellationToken);
            try
            {
                ConsoleAppContext context;
                if (configureGlobalOptions == null)
                {
                    context = new ConsoleAppContext(commandName, args, args, null, null, commandDepth, escapeIndex);
                }
                else
                {
                    var builder = new GlobalOptionsBuilder(args);
                    var globalOptions = configureGlobalOptions(ref builder);
                    context = new ConsoleAppContext(commandName, args, builder.RemainingArgs.ToArray(), null, globalOptions, commandDepth, escapeIndex);
                }
                BuildAndSetServiceProvider(context);

                Task? startHostTask = null;
                StartHostAsyncIfNeeded(posixSignalHandler.Token, ref startHostTask);
                if (startHostTask != null)
                {
                    await startHostTask;
                }

                await Task.Run(() => invoker.InvokeAsync(context, posixSignalHandler.Token)).WaitAsync(posixSignalHandler.TimeoutToken);
            }
            catch (Exception ex)
            {
                if (ex is OperationCanceledException)
                {
                    Environment.ExitCode = 130;
                    return;
                }

                Environment.ExitCode = 1;
                if (ex is ValidationException or ArgumentParseFailedException)
                {
                    LogError(ex.Message);
                }
                else
                {
                    LogError(ex.ToString());
                }
            }
        }
    }

    internal ref struct GlobalOptionsBuilder
    {
        Span<string> args;

        public Span<string> RemainingArgs => args;

        public GlobalOptionsBuilder(Span<string> args)
        {
            this.args = args;
        }

        public T AddGlobalOption<T>([ConstantExpected] string name, [ConstantExpected] string description = "", [ConstantExpected] T defaultValue = default(T))
        {
            var aliasCount = name.AsSpan().Count("|") + 1;
            if (aliasCount == 1)
            {
                for (int i = 0; i < args.Length; i++)
                {
                    if (args[i].Equals(name, StringComparison.OrdinalIgnoreCase))
                    {
                        return ParseArgument<T>(ref args, i);
                    }
                }
            }
            else
            {
                Span<Range> aliases = stackalloc Range[aliasCount];
                if (name.AsSpan().Split(aliases, '|') == 2)
                {
                    var name1 = name.AsSpan()[aliases[0]].Trim();
                    var name2 = name.AsSpan()[aliases[1]].Trim();

                    for (int i = 0; i < args.Length; i++)
                    {
                        if (args[i].AsSpan().Equals(name1, StringComparison.OrdinalIgnoreCase) || args[i].AsSpan().Equals(name2, StringComparison.OrdinalIgnoreCase))
                        {
                            return ParseArgument<T>(ref args, i);
                        }
                    }
                }
                else
                {
                    for (int i = 0; i < args.Length; i++)
                    {
                        if (Contains(name, aliases, args[i]))
                        {
                            return ParseArgument<T>(ref args, i);
                        }
                    }
                }
            }

            return defaultValue;
        }

        public T AddRequiredGlobalOption<T>([ConstantExpected] string name, [ConstantExpected] string description = "")
        {
            if (typeof(T) == typeof(bool)) throw new InvalidOperationException("<bool> can not use in AddRequiredGlobalOption. use AddGlobalOption instead.");

            var aliasCount = name.AsSpan().Count("|") + 1;
            if (aliasCount == 1)
            {
                for (int i = 0; i < args.Length; i++)
                {
                    if (args[i].Equals(name, StringComparison.OrdinalIgnoreCase))
                    {
                        return ParseArgument<T>(ref args, i);
                    }
                }
            }
            else
            {
                Span<Range> aliases = stackalloc Range[aliasCount];
                if (name.AsSpan().Split(aliases, '|') == 2)
                {
                    var name1 = name.AsSpan()[aliases[0]].Trim();
                    var name2 = name.AsSpan()[aliases[1]].Trim();

                    for (int i = 0; i < args.Length; i++)
                    {
                        if (args[i].AsSpan().Equals(name1, StringComparison.OrdinalIgnoreCase) || args[i].AsSpan().Equals(name2, StringComparison.OrdinalIgnoreCase))
                        {
                            return ParseArgument<T>(ref args, i);
                        }
                    }
                }
                else
                {
                    for (int i = 0; i < args.Length; i++)
                    {
                        if (Contains(name, aliases, args[i]))
                        {
                            return ParseArgument<T>(ref args, i);
                        }
                    }
                }
            }

            ThrowRequiredArgumentNotParsed(name);
            return default;
        }

        static T ParseArgument<T>(ref Span<string> args, int i)
        {
            if (typeof(T) == typeof(bool))
            {
                RemoveRange(ref args, i, 1);
                var t = true;
                return Unsafe.As<bool, T>(ref t);
            }
            else
            {
                if ((i + 1) < args.Length)
                {
                    if (TryParse<T>(args[i + 1], out var value))
                    {
                        RemoveRange(ref args, i, 2);
                        return value;
                    }

                    ThrowArgumentParseFailed(args[i], args[i + 1]);
                }
                else
                {
                    ThrowArgumentParseFailed(args[i], "");
                }
            }

            return default;
        }

        static bool TryParse<T>(string s, out T result)
        {
            if (typeof(T) == typeof(string))
            {
                result = Unsafe.As<string, T>(ref s);
                return true;
            }
            else if (typeof(T) == typeof(char))
            {
                if (char.TryParse(s, out var v))
                {
                    result = Unsafe.As<char, T>(ref v);
                    return true;
                }
                result = default;
                return false;
            }
            else if (typeof(T) == typeof(sbyte))
            {
                if (sbyte.TryParse(s, out var v))
                {
                    result = Unsafe.As<sbyte, T>(ref v);
                    return true;
                }
                result = default;
                return false;
            }
            else if (typeof(T) == typeof(byte))
            {
                if (byte.TryParse(s, out var v))
                {
                    result = Unsafe.As<byte, T>(ref v);
                    return true;
                }
                result = default;
                return false;
            }
            else if (typeof(T) == typeof(short))
            {
                if (short.TryParse(s, out var v))
                {
                    result = Unsafe.As<short, T>(ref v);
                    return true;
                }
                result = default;
                return false;
            }
            else if (typeof(T) == typeof(ushort))
            {
                if (ushort.TryParse(s, out var v))
                {
                    result = Unsafe.As<ushort, T>(ref v);
                    return true;
                }
                result = default;
                return false;
            }
            else if (typeof(T) == typeof(int))
            {
                if (int.TryParse(s, out var v))
                {
                    result = Unsafe.As<int, T>(ref v);
                    return true;
                }
                result = default;
                return false;
            }
            else if (typeof(T) == typeof(long))
            {
                if (long.TryParse(s, out var v))
                {
                    result = Unsafe.As<long, T>(ref v);
                    return true;
                }
                result = default;
                return false;
            }
            else if (typeof(T) == typeof(uint))
            {
                if (uint.TryParse(s, out var v))
                {
                    result = Unsafe.As<uint, T>(ref v);
                    return true;
                }
                result = default;
                return false;
            }
            else if (typeof(T) == typeof(ulong))
            {
                if (ulong.TryParse(s, out var v))
                {
                    result = Unsafe.As<ulong, T>(ref v);
                    return true;
                }
                result = default;
                return false;
            }
            else if (typeof(T) == typeof(decimal))
            {
                if (decimal.TryParse(s, out var v))
                {
                    result = Unsafe.As<decimal, T>(ref v);
                    return true;
                }
                result = default;
                return false;
            }
            else if (typeof(T) == typeof(float))
            {
                if (float.TryParse(s, out var v))
                {
                    result = Unsafe.As<float, T>(ref v);
                    return true;
                }
                result = default;
                return false;
            }
            else if (typeof(T) == typeof(double))
            {
                if (double.TryParse(s, out var v))
                {
                    result = Unsafe.As<double, T>(ref v);
                    return true;
                }
                result = default;
                return false;
            }
            else
            {
                if (typeof(T).IsEnum)
                {
                    if (Enum.TryParse(typeof(T), s, ignoreCase: true, out var v))
                    {
                        result = (T)v;
                        return true;
                    }
                }
                result = default;
                return false;
            }
        }

        static void RemoveRange(ref Span<string> args, int index, int length)
        {
            if (length <= 0) return;

            // Fast path(removing from start/end) no need copy
            if (index == 0)
            {
                args = args.Slice(length);
                return;
            }
            else if (index + length == args.Length)
            {
                args = args.Slice(0, index);
                return;
            }

            // Otherwise, need to copy
            var temp = new string[args.Length - length];
            args.Slice(0, index).CopyTo(temp);
            args.Slice(index + length).CopyTo(temp.AsSpan(index));
            args = temp;
        }

        static bool Contains(ReadOnlySpan<char> nameToSlice, Span<Range> ranges, string target)
        {
            for (int i = 0; i < ranges.Length; i++)
            {
                var name = nameToSlice[ranges[i]].Trim();
                if (name.Equals(target, StringComparison.OrdinalIgnoreCase))
                {
                    return true;
                }
            }
            return false;
        }
    }
}
""";

    public const string ConsoleAppBuilderRunStandard = """
// <auto-generated/>
#nullable enable
#pragma warning disable

namespace ConsoleAppFramework;

using System;
using System.Text;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;

internal static partial class ConsoleApp
{
    internal partial class ConsoleAppBuilder
    {
        public void Run(string[] args) => Run(args, true);
        public void Run(string[] args, CancellationToken cancellationToken) => Run(args, true, cancellationToken);

        public void Run(string[] args, bool disposeServiceProvider, CancellationToken cancellationToken = default)
        {
            try
            {
                RunCore(args, cancellationToken);
            }
            finally
            {
                if (disposeServiceProvider)
                {
                    if (ServiceProvider is IDisposable d)
                    {
                        d.Dispose();
                    }
                }
            }
        }

        public Task RunAsync(string[] args) => RunAsync(args, true);
        public Task RunAsync(string[] args, CancellationToken cancellationToken) => RunAsync(args, true, cancellationToken);

        public async Task RunAsync(string[] args, bool disposeServiceProvider, CancellationToken cancellationToken = default)
        {
            try
            {
                Task? task = null;
                RunAsyncCore(args, cancellationToken, ref task!);
                if (task != null)
                {
                    await task;
                }
            }
            finally
            {
                if (disposeServiceProvider)
                {
                    if (ServiceProvider is IAsyncDisposable ad)
                    {
                        await ad.DisposeAsync();
                    }
                    else if (ServiceProvider is IDisposable d)
                    {
                        d.Dispose();
                    }
                }
            }
        }
    }
}
""";

    public const string ConsoleAppBuilderRunWithHost = """
// <auto-generated/>
#nullable enable
#pragma warning disable

namespace ConsoleAppFramework;

using System;
using System.Text;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;

internal static partial class ConsoleApp
{
    internal partial class ConsoleAppBuilder
    {
        Microsoft.Extensions.Hosting.IHost? host;
        bool startHost;

        public void Run(string[] args) => Run(args, true, true, true);
        public void Run(string[] args, CancellationToken cancellationToken) => Run(args, true, true, true, cancellationToken);
        
        public void Run(string[] args, bool startHost, bool stopHost, bool disposeServiceProvider, CancellationToken cancellationToken = default)
        {
            this.startHost = startHost;
            try
            {
                RunCore(args, cancellationToken);
            }
            finally
            {
                if (stopHost && host != null)
                {
                    host.StopAsync(cancellationToken).GetAwaiter().GetResult();
                    host = null;
                }
                if (disposeServiceProvider)
                {
                    if (ServiceProvider is IDisposable d)
                    {
                        d.Dispose();
                    }
                }
            }
        }

        public Task RunAsync(string[] args) => RunAsync(args, true, true, true);
        public Task RunAsync(string[] args, CancellationToken cancellationToken) => RunAsync(args, true, true, true, cancellationToken);

        public async Task RunAsync(string[] args, bool startHost, bool stopHost, bool disposeServiceProvider, CancellationToken cancellationToken = default)
        {
            this.startHost = startHost;
            try
            {
                Task? task = null;
                RunAsyncCore(args, cancellationToken, ref task!);
                if (task != null)
                {
                    await task;
                }
            }
            finally
            {
                if (stopHost && host != null)
                {
                    await host.StopAsync(cancellationToken);
                    host = null;
                }
                if (disposeServiceProvider)
                {
                    if (ServiceProvider is IAsyncDisposable ad)
                    {
                        await ad.DisposeAsync();
                    }
                    else if (ServiceProvider is IDisposable d)
                    {
                        d.Dispose();
                    }
                }
            }
        }
    }
}
""";
}
